package dns

import (
	"fmt"
	"strings"
	"text/template"
)

// pdnsConfigTemplate is the PowerDNS configuration template.
const pdnsConfigTemplate = `# PowerDNS Authoritative Server Configuration
# Generated by Foundry

# API Configuration
api=yes
api-key={{.APIKey}}

# Backend Configuration
launch={{.Backend}}
{{.Backend}}-database={{.DataDir}}/pdns.db

# Web Server (for API)
webserver=yes
webserver-address=0.0.0.0
webserver-port=8081
webserver-allow-from=0.0.0.0/0

# Recursive Resolution
# Note: PowerDNS Authoritative doesn't do recursion directly
# Use recursor configuration or run pdns-recursor separately
# For now, we'll configure forwarders in the recursor config

# Logging
loglevel=4
log-dns-queries=no
log-dns-details=no

# Security
security-poll-suffix=
disable-syslog=no
guardian=yes

# Performance
cache-ttl=20
query-cache-ttl=20
negquery-cache-ttl=60
`

// recursorConfigTemplate is the PowerDNS Recursor configuration template.
const recursorConfigTemplate = `# PowerDNS Recursor Configuration
# Generated by Foundry

# Listening
local-address=0.0.0.0
local-port=53

# Forwarding
forward-zones-recurse=.={{.Forwarders}}

# API Configuration
api-key={{.APIKey}}
webserver=yes
webserver-address=0.0.0.0
webserver-port=8082
webserver-allow-from=0.0.0.0/0

# Security
security-poll-suffix=

# Performance
max-cache-entries=1000000
max-cache-ttl=86400
`

// GenerateAuthConfig generates the PowerDNS Authoritative Server configuration.
func GenerateAuthConfig(cfg *Config) (string, error) {
	if cfg == nil {
		return "", fmt.Errorf("config cannot be nil")
	}

	if cfg.APIKey == "" {
		return "", fmt.Errorf("API key is required")
	}

	tmpl, err := template.New("pdns-auth").Parse(pdnsConfigTemplate)
	if err != nil {
		return "", fmt.Errorf("failed to parse template: %w", err)
	}

	var buf strings.Builder
	if err := tmpl.Execute(&buf, cfg); err != nil {
		return "", fmt.Errorf("failed to execute template: %w", err)
	}

	return buf.String(), nil
}

// GenerateRecursorConfig generates the PowerDNS Recursor configuration.
func GenerateRecursorConfig(cfg *Config) (string, error) {
	if cfg == nil {
		return "", fmt.Errorf("config cannot be nil")
	}

	if cfg.APIKey == "" {
		return "", fmt.Errorf("API key is required")
	}

	if len(cfg.Forwarders) == 0 {
		return "", fmt.Errorf("at least one forwarder is required")
	}

	// Create template data with joined forwarders
	data := struct {
		APIKey     string
		Forwarders string
	}{
		APIKey:     cfg.APIKey,
		Forwarders: strings.Join(cfg.Forwarders, ";"),
	}

	tmpl, err := template.New("pdns-recursor").Parse(recursorConfigTemplate)
	if err != nil {
		return "", fmt.Errorf("failed to parse template: %w", err)
	}

	var buf strings.Builder
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("failed to execute template: %w", err)
	}

	return buf.String(), nil
}
